import { BufferGeometry, Float32BufferAttribute, Geometry } from 'three';
import earcut from 'earcut';

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var getInterpolatedVals = function getInterpolatedVals(start, end, numPnts) {
  var result = [];

  for (var i = 1; i <= numPnts; i++) {
    result.push(start + (end - start) * i / (numPnts + 1));
  }

  return result;
};

var interpolateLine = function interpolateLine() {
  var lineCoords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var maxDegDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var result = [];
  var prevPnt = null;
  lineCoords.forEach(function (pnt) {
    if (prevPnt) {
      var dist = Math.sqrt(Math.pow(pnt[0] - prevPnt[0], 2) + Math.pow(pnt[1] - prevPnt[1], 2));

      if (dist > maxDegDistance) {
        var numAdditionalPnts = Math.floor(dist / maxDegDistance);
        var lngs = getInterpolatedVals(prevPnt[0], pnt[0], numAdditionalPnts);
        var lats = getInterpolatedVals(prevPnt[1], pnt[1], numAdditionalPnts);

        for (var i = 0, len = lngs.length; i < len; i++) {
          result.push([lngs[i], lats[i]]);
        }
      }
    }

    result.push(prevPnt = pnt);
  });
  return result;
};

var THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
: {
  BufferGeometry: BufferGeometry,
  Float32BufferAttribute: Float32BufferAttribute,
  Geometry: Geometry
};

function GeoJsonGeometry(geoJson) {
  var _this = this;

  var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;
  THREE.BufferGeometry.call(this);
  this.type = 'GeoJsonGeometry';
  this.parameters = {
    geoJson: geoJson,
    radius: radius,
    resolution: resolution
  }; // process various geometry types

  var groups = ({
    Point: genPoint,
    MultiPoint: genMultiPoint,
    LineString: genLineString,
    MultiLineString: genMultiLineString,
    Polygon: genPolygon,
    MultiPolygon: genMultiPolygon
  }[geoJson.type] || function () {
    return [];
  })(geoJson.coordinates, radius); // concat groups


  var indices = [],
      vertices = [];
  var groupCnt = 0;
  groups.forEach(function (newG) {
    var prevIndCnt = indices.length;
    concatGroup({
      indices: indices,
      vertices: vertices
    }, newG);

    _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);
  }); // build geometry

  indices.length && this.setIndex(indices);
  vertices.length && this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); //

  function genPoint(coords, r) {
    var vertices = polar2Cartesian(coords[1], coords[0], r);
    var indices = [];
    return [{
      vertices: vertices,
      indices: indices
    }];
  }

  function genMultiPoint(coords, r) {
    var result = {
      vertices: [],
      indices: []
    };
    coords.map(function (c) {
      return genPoint(c, r);
    }).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          newPnt = _ref2[0];

      concatGroup(result, newPnt);
    });
    return [result];
  }

  function genLineString(coords, r) {
    var coords3d = interpolateLine(coords, resolution).map(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          lng = _ref4[0],
          lat = _ref4[1];

      return polar2Cartesian(lat, lng, r);
    });

    var _earcut$flatten = earcut.flatten([coords3d]),
        vertices = _earcut$flatten.vertices;

    var numPoints = Math.round(vertices.length / 3);
    var indices = [];

    for (var vIdx = 1; vIdx < numPoints; vIdx++) {
      indices.push(vIdx - 1, vIdx);
    }

    return [{
      vertices: vertices,
      indices: indices
    }];
  }

  function genMultiLineString(coords, r) {
    var result = {
      vertices: [],
      indices: []
    };
    coords.map(function (c) {
      return genLineString(c, r);
    }).forEach(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
          newLine = _ref6[0];

      concatGroup(result, newLine);
    });
    return [result];
  }

  function genPolygon(coords, r) {
    var coords3d = coords.map(function (coordsSegment) {
      return interpolateLine(coordsSegment, resolution).map(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
            lng = _ref8[0],
            lat = _ref8[1];

        return polar2Cartesian(lat, lng, r);
      });
    }); // Each point generates 3 vertice items (x,y,z).

    var _earcut$flatten2 = earcut.flatten(coords3d),
        vertices = _earcut$flatten2.vertices,
        holes = _earcut$flatten2.holes;

    var firstHoleIdx = holes[0] || Infinity;
    var outerVertices = vertices.slice(0, firstHoleIdx);
    var holeVertices = vertices.slice(firstHoleIdx);
    var holesIdx = new Set(holes);
    var numPoints = Math.round(vertices.length / 3);
    var outerIndices = [],
        holeIndices = [];

    for (var vIdx = 1; vIdx < numPoints; vIdx++) {
      if (!holesIdx.has(vIdx)) {
        if (vIdx < firstHoleIdx) {
          outerIndices.push(vIdx - 1, vIdx);
        } else {
          holeIndices.push(vIdx - 1 - firstHoleIdx, vIdx - firstHoleIdx);
        }
      }
    }

    var groups = [{
      indices: outerIndices,
      vertices: outerVertices
    }];

    if (holes.length) {
      groups.push({
        indices: holeIndices,
        vertices: holeVertices
      });
    }

    return groups;
  }

  function genMultiPolygon(coords, r) {
    var outer = {
      vertices: [],
      indices: []
    };
    var holes = {
      vertices: [],
      indices: []
    };
    coords.map(function (c) {
      return genPolygon(c, r);
    }).forEach(function (_ref9) {
      var _ref10 = _slicedToArray(_ref9, 2),
          newOuter = _ref10[0],
          newHoles = _ref10[1];

      concatGroup(outer, newOuter);
      newHoles && concatGroup(holes, newHoles);
    });
    var groups = [outer];
    holes.vertices.length && groups.push(holes);
    return groups;
  }
}

GeoJsonGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
GeoJsonGeometry.prototype.constructor = GeoJsonGeometry; //

function concatGroup(main, extra) {
  var prevVertCnt = Math.round(main.vertices.length / 3);
  concatArr(main.vertices, extra.vertices);
  concatArr(main.indices, extra.indices.map(function (ind) {
    return ind + prevVertCnt;
  }));
}

function concatArr(target, src) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = src[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var e = _step.value;
      target.push(e);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function polar2Cartesian(lat, lng) {
  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var phi = (90 - lat) * Math.PI / 180;
  var theta = (90 - lng) * Math.PI / 180;
  return [r * Math.sin(phi) * Math.cos(theta), // x
  r * Math.cos(phi), // y
  r * Math.sin(phi) * Math.sin(theta) // z
  ];
}

export { GeoJsonGeometry };
