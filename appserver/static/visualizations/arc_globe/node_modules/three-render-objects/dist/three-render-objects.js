// Version 1.9.0 three-render-objects - https://github.com/vasturiano/three-render-objects
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('three')) :
  typeof define === 'function' && define.amd ? define(['three'], factory) :
  (global = global || self, global.ThreeRenderObjects = factory(global.THREE));
}(this, (function (three$1) { 'use strict';

  var three$1__default = 'default' in three$1 ? three$1['default'] : three$1;

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css = ".scene-nav-info {\n  bottom: 5px;\n  width: 100%;\n  text-align: center;\n  color: slategrey;\n  opacity: 0.7;\n  font-size: 10px;\n}\n\n.scene-tooltip {\n  color: lavender;\n  font-size: 15px;\n}\n\n.scene-nav-info, .scene-tooltip {\n  position: absolute;\n  font-family: sans-serif;\n  pointer-events: none;\n}";
  styleInject(css);

  /**
   * @author Eberhard Graether / http://egraether.com/
   * @author Mark Lundin 	/ http://mark-lundin.com
   * @author Simone Manini / http://daron1337.github.io
   * @author Luca Antiga 	/ http://lantiga.github.io

   ** three-trackballcontrols module
   ** @author Jon Lim / http://jonlim.ca
   */

  var THREE = window.THREE || three$1__default;

  var TrackballControls;
  var threeTrackballcontrols = TrackballControls = function ( object, domElement ) {

  	var _this = this;
  	var STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

  	this.object = object;
  	this.domElement = ( domElement !== undefined ) ? domElement : document;

  	// API

  	this.enabled = true;

  	this.screen = { left: 0, top: 0, width: 0, height: 0 };

  	this.rotateSpeed = 1.0;
  	this.zoomSpeed = 1.2;
  	this.panSpeed = 0.3;

  	this.noRotate = false;
  	this.noZoom = false;
  	this.noPan = false;

  	this.staticMoving = false;
  	this.dynamicDampingFactor = 0.2;

  	this.minDistance = 0;
  	this.maxDistance = Infinity;

  	/**
  	 * `KeyboardEvent.keyCode` values which should trigger the different 
  	 * interaction states. Each element can be a single code or an array
  	 * of codes. All elements are required.
  	 */
  	this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

  	// internals

  	this.target = new THREE.Vector3();

  	var EPS = 0.000001;

  	var lastPosition = new THREE.Vector3();

  	var _state = STATE.NONE,
  	_prevState = STATE.NONE,

  	_eye = new THREE.Vector3(),

  	_movePrev = new THREE.Vector2(),
  	_moveCurr = new THREE.Vector2(),

  	_lastAxis = new THREE.Vector3(),
  	_lastAngle = 0,

  	_zoomStart = new THREE.Vector2(),
  	_zoomEnd = new THREE.Vector2(),

  	_touchZoomDistanceStart = 0,
  	_touchZoomDistanceEnd = 0,

  	_panStart = new THREE.Vector2(),
  	_panEnd = new THREE.Vector2();

  	// for reset

  	this.target0 = this.target.clone();
  	this.position0 = this.object.position.clone();
  	this.up0 = this.object.up.clone();

  	// events

  	var changeEvent = { type: 'change' };
  	var startEvent = { type: 'start' };
  	var endEvent = { type: 'end' };


  	// methods

  	this.handleResize = function () {

  		if ( this.domElement === document ) {

  			this.screen.left = 0;
  			this.screen.top = 0;
  			this.screen.width = window.innerWidth;
  			this.screen.height = window.innerHeight;

  		} else {

  			var box = this.domElement.getBoundingClientRect();
  			// adjustments come from similar code in the jquery offset() function
  			var d = this.domElement.ownerDocument.documentElement;
  			this.screen.left = box.left + window.pageXOffset - d.clientLeft;
  			this.screen.top = box.top + window.pageYOffset - d.clientTop;
  			this.screen.width = box.width;
  			this.screen.height = box.height;

  		}

  	};

  	this.handleEvent = function ( event ) {

  		if ( typeof this[ event.type ] == 'function' ) {

  			this[ event.type ]( event );

  		}

  	};

  	var getMouseOnScreen = ( function () {

  		var vector = new THREE.Vector2();

  		return function getMouseOnScreen( pageX, pageY ) {

  			vector.set(
  				( pageX - _this.screen.left ) / _this.screen.width,
  				( pageY - _this.screen.top ) / _this.screen.height
  			);

  			return vector;

  		};

  	}() );

  	var getMouseOnCircle = ( function () {

  		var vector = new THREE.Vector2();

  		return function getMouseOnCircle( pageX, pageY ) {

  			vector.set(
  				( ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / ( _this.screen.width * 0.5 ) ),
  				( ( _this.screen.height + 2 * ( _this.screen.top - pageY ) ) / _this.screen.width ) // screen.width intentional
  			);

  			return vector;

  		};

  	}() );

  	this.rotateCamera = ( function() {

  		var axis = new THREE.Vector3(),
  			quaternion = new THREE.Quaternion(),
  			eyeDirection = new THREE.Vector3(),
  			objectUpDirection = new THREE.Vector3(),
  			objectSidewaysDirection = new THREE.Vector3(),
  			moveDirection = new THREE.Vector3(),
  			angle;

  		return function rotateCamera() {

  			moveDirection.set( _moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0 );
  			angle = moveDirection.length();

  			if ( angle ) {

  				_eye.copy( _this.object.position ).sub( _this.target );

  				eyeDirection.copy( _eye ).normalize();
  				objectUpDirection.copy( _this.object.up ).normalize();
  				objectSidewaysDirection.crossVectors( objectUpDirection, eyeDirection ).normalize();

  				objectUpDirection.setLength( _moveCurr.y - _movePrev.y );
  				objectSidewaysDirection.setLength( _moveCurr.x - _movePrev.x );

  				moveDirection.copy( objectUpDirection.add( objectSidewaysDirection ) );

  				axis.crossVectors( moveDirection, _eye ).normalize();

  				angle *= _this.rotateSpeed;
  				quaternion.setFromAxisAngle( axis, angle );

  				_eye.applyQuaternion( quaternion );
  				_this.object.up.applyQuaternion( quaternion );

  				_lastAxis.copy( axis );
  				_lastAngle = angle;

  			} else if ( ! _this.staticMoving && _lastAngle ) {

  				_lastAngle *= Math.sqrt( 1.0 - _this.dynamicDampingFactor );
  				_eye.copy( _this.object.position ).sub( _this.target );
  				quaternion.setFromAxisAngle( _lastAxis, _lastAngle );
  				_eye.applyQuaternion( quaternion );
  				_this.object.up.applyQuaternion( quaternion );

  			}

  			_movePrev.copy( _moveCurr );

  		};

  	}() );


  	this.zoomCamera = function () {

  		var factor;

  		if ( _state === STATE.TOUCH_ZOOM_PAN ) {

  			factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
  			_touchZoomDistanceStart = _touchZoomDistanceEnd;
  			_eye.multiplyScalar( factor );

  		} else {

  			factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;

  			if ( factor !== 1.0 && factor > 0.0 ) {

  				_eye.multiplyScalar( factor );

  			}

  			if ( _this.staticMoving ) {

  				_zoomStart.copy( _zoomEnd );

  			} else {

  				_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;

  			}

  		}

  	};

  	this.panCamera = ( function() {

  		var mouseChange = new THREE.Vector2(),
  			objectUp = new THREE.Vector3(),
  			pan = new THREE.Vector3();

  		return function panCamera() {

  			mouseChange.copy( _panEnd ).sub( _panStart );

  			if ( mouseChange.lengthSq() ) {

  				mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

  				pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
  				pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );

  				_this.object.position.add( pan );
  				_this.target.add( pan );

  				if ( _this.staticMoving ) {

  					_panStart.copy( _panEnd );

  				} else {

  					_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

  				}

  			}

  		};

  	}() );

  	this.checkDistances = function () {

  		if ( ! _this.noZoom || ! _this.noPan ) {

  			if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {

  				_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );
  				_zoomStart.copy( _zoomEnd );

  			}

  			if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {

  				_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );
  				_zoomStart.copy( _zoomEnd );

  			}

  		}

  	};

  	this.update = function () {

  		_eye.subVectors( _this.object.position, _this.target );

  		if ( ! _this.noRotate ) {

  			_this.rotateCamera();

  		}

  		if ( ! _this.noZoom ) {

  			_this.zoomCamera();

  		}

  		if ( ! _this.noPan ) {

  			_this.panCamera();

  		}

  		_this.object.position.addVectors( _this.target, _eye );

  		_this.checkDistances();

  		_this.object.lookAt( _this.target );

  		if ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {

  			_this.dispatchEvent( changeEvent );

  			lastPosition.copy( _this.object.position );

  		}

  	};

  	this.reset = function () {

  		_state = STATE.NONE;
  		_prevState = STATE.NONE;

  		_this.target.copy( _this.target0 );
  		_this.object.position.copy( _this.position0 );
  		_this.object.up.copy( _this.up0 );

  		_eye.subVectors( _this.object.position, _this.target );

  		_this.object.lookAt( _this.target );

  		_this.dispatchEvent( changeEvent );

  		lastPosition.copy( _this.object.position );

  	};

  	// helpers

  	/**
  	 * Checks if the pressed key is any of the configured modifier keys for
  	 * a specified behavior.
  	 * 
  	 * @param {number | number[]} keys 
  	 * @param {number} key 
  	 * 
  	 * @returns {boolean} `true` if `keys` contains or equals `key`
  	 */
  	function containsKey(keys, key) {
  		if (Array.isArray(keys)) {
  			return keys.indexOf(key) !== -1;
  		} else {
  			return keys === key;
  		}
  	}

  	// listeners

  	function keydown( event ) {

  		if ( _this.enabled === false ) return;

  		window.removeEventListener( 'keydown', keydown );

  		_prevState = _state;

  		if ( _state !== STATE.NONE ) {

  			return;

  		} else if ( containsKey( _this.keys[ STATE.ROTATE ], event.keyCode ) && ! _this.noRotate ) {

  			_state = STATE.ROTATE;

  		} else if ( containsKey( _this.keys[ STATE.ZOOM ], event.keyCode ) && ! _this.noZoom ) {

  			_state = STATE.ZOOM;

  		} else if ( containsKey( _this.keys[ STATE.PAN ], event.keyCode ) && ! _this.noPan ) {

  			_state = STATE.PAN;

  		}

  	}

  	function keyup( event ) {

  		if ( _this.enabled === false ) return;

  		_state = _prevState;

  		window.addEventListener( 'keydown', keydown, false );

  	}

  	function mousedown( event ) {

  		if ( _this.enabled === false ) return;

  		event.preventDefault();
  		event.stopPropagation();

  		if ( _state === STATE.NONE ) {

  			_state = event.button;

  		}

  		if ( _state === STATE.ROTATE && ! _this.noRotate ) {

  			_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );
  			_movePrev.copy( _moveCurr );

  		} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {

  			_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
  			_zoomEnd.copy( _zoomStart );

  		} else if ( _state === STATE.PAN && ! _this.noPan ) {

  			_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
  			_panEnd.copy( _panStart );

  		}

  		document.addEventListener( 'mousemove', mousemove, false );
  		document.addEventListener( 'mouseup', mouseup, false );

  		_this.dispatchEvent( startEvent );

  	}

  	function mousemove( event ) {

  		if ( _this.enabled === false ) return;

  		event.preventDefault();
  		event.stopPropagation();

  		if ( _state === STATE.ROTATE && ! _this.noRotate ) {

  			_movePrev.copy( _moveCurr );
  			_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );

  		} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {

  			_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

  		} else if ( _state === STATE.PAN && ! _this.noPan ) {

  			_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

  		}

  	}

  	function mouseup( event ) {

  		if ( _this.enabled === false ) return;

  		event.preventDefault();
  		event.stopPropagation();

  		_state = STATE.NONE;

  		document.removeEventListener( 'mousemove', mousemove );
  		document.removeEventListener( 'mouseup', mouseup );
  		_this.dispatchEvent( endEvent );

  	}

  	function mousewheel( event ) {

  		if ( _this.enabled === false ) return;

  		event.preventDefault();
  		event.stopPropagation();

  		switch ( event.deltaMode ) {

  			case 2:
  				// Zoom in pages
  				_zoomStart.y -= event.deltaY * 0.025;
  				break;

  			case 1:
  				// Zoom in lines
  				_zoomStart.y -= event.deltaY * 0.01;
  				break;

  			default:
  				// undefined, 0, assume pixels
  				_zoomStart.y -= event.deltaY * 0.00025;
  				break;

  		}

  		_this.dispatchEvent( startEvent );
  		_this.dispatchEvent( endEvent );

  	}

  	function touchstart( event ) {

  		if ( _this.enabled === false ) return;

  		switch ( event.touches.length ) {

  			case 1:
  				_state = STATE.TOUCH_ROTATE;
  				_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
  				_movePrev.copy( _moveCurr );
  				break;

  			default: // 2 or more
  				_state = STATE.TOUCH_ZOOM_PAN;
  				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
  				_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

  				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
  				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
  				_panStart.copy( getMouseOnScreen( x, y ) );
  				_panEnd.copy( _panStart );
  				break;

  		}

  		_this.dispatchEvent( startEvent );

  	}

  	function touchmove( event ) {

  		if ( _this.enabled === false ) return;

  		event.preventDefault();
  		event.stopPropagation();

  		switch ( event.touches.length ) {

  			case 1:
  				_movePrev.copy( _moveCurr );
  				_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
  				break;

  			default: // 2 or more
  				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
  				_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

  				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
  				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
  				_panEnd.copy( getMouseOnScreen( x, y ) );
  				break;

  		}

  	}

  	function touchend( event ) {

  		if ( _this.enabled === false ) return;

  		switch ( event.touches.length ) {

  			case 0:
  				_state = STATE.NONE;
  				break;

  			case 1:
  				_state = STATE.TOUCH_ROTATE;
  				_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
  				_movePrev.copy( _moveCurr );
  				break;

  		}

  		_this.dispatchEvent( endEvent );

  	}

  	function contextmenu( event ) {

  		if ( _this.enabled === false ) return;

  		event.preventDefault();

  	}

  	this.dispose = function() {

  		this.domElement.removeEventListener( 'contextmenu', contextmenu, false );
  		this.domElement.removeEventListener( 'mousedown', mousedown, false );
  		this.domElement.removeEventListener( 'wheel', mousewheel, false );

  		this.domElement.removeEventListener( 'touchstart', touchstart, false );
  		this.domElement.removeEventListener( 'touchend', touchend, false );
  		this.domElement.removeEventListener( 'touchmove', touchmove, false );

  		document.removeEventListener( 'mousemove', mousemove, false );
  		document.removeEventListener( 'mouseup', mouseup, false );

  		window.removeEventListener( 'keydown', keydown, false );
  		window.removeEventListener( 'keyup', keyup, false );

  	};

  	this.domElement.addEventListener( 'contextmenu', contextmenu, false );
  	this.domElement.addEventListener( 'mousedown', mousedown, false );
  	this.domElement.addEventListener( 'wheel', mousewheel, false );

  	this.domElement.addEventListener( 'touchstart', touchstart, false );
  	this.domElement.addEventListener( 'touchend', touchend, false );
  	this.domElement.addEventListener( 'touchmove', touchmove, false );

  	window.addEventListener( 'keydown', keydown, false );
  	window.addEventListener( 'keyup', keyup, false );

  	this.handleResize();

  	// force an update at start
  	this.update();

  };

  TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );

  var threeOrbitControls = function( THREE ) {
  	/**
  	 * @author qiao / https://github.com/qiao
  	 * @author mrdoob / http://mrdoob.com
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 * @author erich666 / http://erichaines.com
  	 */

  // This set of controls performs orbiting, dollying (zooming), and panning.
  // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
  //
  //    Orbit - left mouse / touch: one finger move
  //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
  //    Pan - right mouse, or arrow keys / touch: three finter swipe

  	function OrbitControls( object, domElement ) {

  		this.object = object;

  		this.domElement = ( domElement !== undefined ) ? domElement : document;

  		// Set to false to disable this control
  		this.enabled = true;

  		// "target" sets the location of focus, where the object orbits around
  		this.target = new THREE.Vector3();

  		// How far you can dolly in and out ( PerspectiveCamera only )
  		this.minDistance = 0;
  		this.maxDistance = Infinity;

  		// How far you can zoom in and out ( OrthographicCamera only )
  		this.minZoom = 0;
  		this.maxZoom = Infinity;

  		// How far you can orbit vertically, upper and lower limits.
  		// Range is 0 to Math.PI radians.
  		this.minPolarAngle = 0; // radians
  		this.maxPolarAngle = Math.PI; // radians

  		// How far you can orbit horizontally, upper and lower limits.
  		// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
  		this.minAzimuthAngle = - Infinity; // radians
  		this.maxAzimuthAngle = Infinity; // radians

  		// Set to true to enable damping (inertia)
  		// If damping is enabled, you must call controls.update() in your animation loop
  		this.enableDamping = false;
  		this.dampingFactor = 0.25;

  		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  		// Set to false to disable zooming
  		this.enableZoom = true;
  		this.zoomSpeed = 1.0;

  		// Set to false to disable rotating
  		this.enableRotate = true;
  		this.rotateSpeed = 1.0;

  		// Set to false to disable panning
  		this.enablePan = true;
  		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

  		// Set to true to automatically rotate around the target
  		// If auto-rotate is enabled, you must call controls.update() in your animation loop
  		this.autoRotate = false;
  		this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

  		// Set to false to disable use of the keys
  		this.enableKeys = true;

  		// The four arrow keys
  		this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

  		// Mouse buttons
  		this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

  		// for reset
  		this.target0 = this.target.clone();
  		this.position0 = this.object.position.clone();
  		this.zoom0 = this.object.zoom;

  		//
  		// public methods
  		//

  		this.getPolarAngle = function () {

  			return spherical.phi;

  		};

  		this.getAzimuthalAngle = function () {

  			return spherical.theta;

  		};

  		this.reset = function () {

  			scope.target.copy( scope.target0 );
  			scope.object.position.copy( scope.position0 );
  			scope.object.zoom = scope.zoom0;

  			scope.object.updateProjectionMatrix();
  			scope.dispatchEvent( changeEvent );

  			scope.update();

  			state = STATE.NONE;

  		};

  		// this method is exposed, but perhaps it would be better if we can make it private...
  		this.update = function() {

  			var offset = new THREE.Vector3();

  			// so camera.up is the orbit axis
  			var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
  			var quatInverse = quat.clone().inverse();

  			var lastPosition = new THREE.Vector3();
  			var lastQuaternion = new THREE.Quaternion();

  			return function update () {

  				var position = scope.object.position;

  				offset.copy( position ).sub( scope.target );

  				// rotate offset to "y-axis-is-up" space
  				offset.applyQuaternion( quat );

  				// angle from z-axis around y-axis
  				spherical.setFromVector3( offset );

  				if ( scope.autoRotate && state === STATE.NONE ) {

  					rotateLeft( getAutoRotationAngle() );

  				}

  				spherical.theta += sphericalDelta.theta;
  				spherical.phi += sphericalDelta.phi;

  				// restrict theta to be between desired limits
  				spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

  				// restrict phi to be between desired limits
  				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

  				spherical.makeSafe();


  				spherical.radius *= scale;

  				// restrict radius to be between desired limits
  				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

  				// move target to panned location
  				scope.target.add( panOffset );

  				offset.setFromSpherical( spherical );

  				// rotate offset back to "camera-up-vector-is-up" space
  				offset.applyQuaternion( quatInverse );

  				position.copy( scope.target ).add( offset );

  				scope.object.lookAt( scope.target );

  				if ( scope.enableDamping === true ) {

  					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
  					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

  				} else {

  					sphericalDelta.set( 0, 0, 0 );

  				}

  				scale = 1;
  				panOffset.set( 0, 0, 0 );

  				// update condition is:
  				// min(camera displacement, camera rotation in radians)^2 > EPS
  				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

  				if ( zoomChanged ||
  					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
  					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

  					scope.dispatchEvent( changeEvent );

  					lastPosition.copy( scope.object.position );
  					lastQuaternion.copy( scope.object.quaternion );
  					zoomChanged = false;

  					return true;

  				}

  				return false;

  			};

  		}();

  		this.dispose = function() {

  			scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
  			scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
  			scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

  			scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
  			scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
  			scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

  			document.removeEventListener( 'mousemove', onMouseMove, false );
  			document.removeEventListener( 'mouseup', onMouseUp, false );

  			window.removeEventListener( 'keydown', onKeyDown, false );

  			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

  		};

  		//
  		// internals
  		//

  		var scope = this;

  		var changeEvent = { type: 'change' };
  		var startEvent = { type: 'start' };
  		var endEvent = { type: 'end' };

  		var STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };

  		var state = STATE.NONE;

  		var EPS = 0.000001;

  		// current position in spherical coordinates
  		var spherical = new THREE.Spherical();
  		var sphericalDelta = new THREE.Spherical();

  		var scale = 1;
  		var panOffset = new THREE.Vector3();
  		var zoomChanged = false;

  		var rotateStart = new THREE.Vector2();
  		var rotateEnd = new THREE.Vector2();
  		var rotateDelta = new THREE.Vector2();

  		var panStart = new THREE.Vector2();
  		var panEnd = new THREE.Vector2();
  		var panDelta = new THREE.Vector2();

  		var dollyStart = new THREE.Vector2();
  		var dollyEnd = new THREE.Vector2();
  		var dollyDelta = new THREE.Vector2();

  		function getAutoRotationAngle() {

  			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

  		}

  		function getZoomScale() {

  			return Math.pow( 0.95, scope.zoomSpeed );

  		}

  		function rotateLeft( angle ) {

  			sphericalDelta.theta -= angle;

  		}

  		function rotateUp( angle ) {

  			sphericalDelta.phi -= angle;

  		}

  		var panLeft = function() {

  			var v = new THREE.Vector3();

  			return function panLeft( distance, objectMatrix ) {

  				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
  				v.multiplyScalar( - distance );

  				panOffset.add( v );

  			};

  		}();

  		var panUp = function() {

  			var v = new THREE.Vector3();

  			return function panUp( distance, objectMatrix ) {

  				v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
  				v.multiplyScalar( distance );

  				panOffset.add( v );

  			};

  		}();

  		// deltaX and deltaY are in pixels; right and down are positive
  		var pan = function() {

  			var offset = new THREE.Vector3();

  			return function pan ( deltaX, deltaY ) {

  				var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  				if ( scope.object instanceof THREE.PerspectiveCamera ) {

  					// perspective
  					var position = scope.object.position;
  					offset.copy( position ).sub( scope.target );
  					var targetDistance = offset.length();

  					// half of the fov is center to top of screen
  					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

  					// we actually don't use screenWidth, since perspective camera is fixed to screen height
  					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
  					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

  				} else if ( scope.object instanceof THREE.OrthographicCamera ) {

  					// orthographic
  					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
  					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

  				} else {

  					// camera neither orthographic nor perspective
  					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
  					scope.enablePan = false;

  				}

  			};

  		}();

  		function dollyIn( dollyScale ) {

  			if ( scope.object instanceof THREE.PerspectiveCamera ) {

  				scale /= dollyScale;

  			} else if ( scope.object instanceof THREE.OrthographicCamera ) {

  				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
  				scope.object.updateProjectionMatrix();
  				zoomChanged = true;

  			} else {

  				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  				scope.enableZoom = false;

  			}

  		}

  		function dollyOut( dollyScale ) {

  			if ( scope.object instanceof THREE.PerspectiveCamera ) {

  				scale *= dollyScale;

  			} else if ( scope.object instanceof THREE.OrthographicCamera ) {

  				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
  				scope.object.updateProjectionMatrix();
  				zoomChanged = true;

  			} else {

  				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  				scope.enableZoom = false;

  			}

  		}

  		//
  		// event callbacks - update the object state
  		//

  		function handleMouseDownRotate( event ) {

  			//console.log( 'handleMouseDownRotate' );

  			rotateStart.set( event.clientX, event.clientY );

  		}

  		function handleMouseDownDolly( event ) {

  			//console.log( 'handleMouseDownDolly' );

  			dollyStart.set( event.clientX, event.clientY );

  		}

  		function handleMouseDownPan( event ) {

  			//console.log( 'handleMouseDownPan' );

  			panStart.set( event.clientX, event.clientY );

  		}

  		function handleMouseMoveRotate( event ) {

  			//console.log( 'handleMouseMoveRotate' );

  			rotateEnd.set( event.clientX, event.clientY );
  			rotateDelta.subVectors( rotateEnd, rotateStart );

  			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  			// rotating across whole screen goes 360 degrees around
  			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

  			// rotating up and down along whole screen attempts to go 360, but limited to 180
  			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

  			rotateStart.copy( rotateEnd );

  			scope.update();

  		}

  		function handleMouseMoveDolly( event ) {

  			//console.log( 'handleMouseMoveDolly' );

  			dollyEnd.set( event.clientX, event.clientY );

  			dollyDelta.subVectors( dollyEnd, dollyStart );

  			if ( dollyDelta.y > 0 ) {

  				dollyIn( getZoomScale() );

  			} else if ( dollyDelta.y < 0 ) {

  				dollyOut( getZoomScale() );

  			}

  			dollyStart.copy( dollyEnd );

  			scope.update();

  		}

  		function handleMouseMovePan( event ) {

  			//console.log( 'handleMouseMovePan' );

  			panEnd.set( event.clientX, event.clientY );

  			panDelta.subVectors( panEnd, panStart );

  			pan( panDelta.x, panDelta.y );

  			panStart.copy( panEnd );

  			scope.update();

  		}

  		function handleMouseWheel( event ) {

  			//console.log( 'handleMouseWheel' );

  			if ( event.deltaY < 0 ) {

  				dollyOut( getZoomScale() );

  			} else if ( event.deltaY > 0 ) {

  				dollyIn( getZoomScale() );

  			}

  			scope.update();

  		}

  		function handleKeyDown( event ) {

  			//console.log( 'handleKeyDown' );

  			switch ( event.keyCode ) {

  				case scope.keys.UP:
  					pan( 0, scope.keyPanSpeed );
  					scope.update();
  					break;

  				case scope.keys.BOTTOM:
  					pan( 0, - scope.keyPanSpeed );
  					scope.update();
  					break;

  				case scope.keys.LEFT:
  					pan( scope.keyPanSpeed, 0 );
  					scope.update();
  					break;

  				case scope.keys.RIGHT:
  					pan( - scope.keyPanSpeed, 0 );
  					scope.update();
  					break;

  			}

  		}

  		function handleTouchStartRotate( event ) {

  			//console.log( 'handleTouchStartRotate' );

  			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		}

  		function handleTouchStartDolly( event ) {

  			//console.log( 'handleTouchStartDolly' );

  			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  			var distance = Math.sqrt( dx * dx + dy * dy );

  			dollyStart.set( 0, distance );

  		}

  		function handleTouchStartPan( event ) {

  			//console.log( 'handleTouchStartPan' );

  			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		}

  		function handleTouchMoveRotate( event ) {

  			//console.log( 'handleTouchMoveRotate' );

  			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
  			rotateDelta.subVectors( rotateEnd, rotateStart );

  			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  			// rotating across whole screen goes 360 degrees around
  			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

  			// rotating up and down along whole screen attempts to go 360, but limited to 180
  			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

  			rotateStart.copy( rotateEnd );

  			scope.update();

  		}

  		function handleTouchMoveDolly( event ) {

  			//console.log( 'handleTouchMoveDolly' );

  			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  			var distance = Math.sqrt( dx * dx + dy * dy );

  			dollyEnd.set( 0, distance );

  			dollyDelta.subVectors( dollyEnd, dollyStart );

  			if ( dollyDelta.y > 0 ) {

  				dollyOut( getZoomScale() );

  			} else if ( dollyDelta.y < 0 ) {

  				dollyIn( getZoomScale() );

  			}

  			dollyStart.copy( dollyEnd );

  			scope.update();

  		}

  		function handleTouchMovePan( event ) {

  			//console.log( 'handleTouchMovePan' );

  			panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  			panDelta.subVectors( panEnd, panStart );

  			pan( panDelta.x, panDelta.y );

  			panStart.copy( panEnd );

  			scope.update();

  		}

  		//
  		// event handlers - FSM: listen for events and reset state
  		//

  		function onMouseDown( event ) {

  			if ( scope.enabled === false ) return;

  			event.preventDefault();

  			if ( event.button === scope.mouseButtons.ORBIT ) {

  				if ( scope.enableRotate === false ) return;

  				handleMouseDownRotate( event );

  				state = STATE.ROTATE;

  			} else if ( event.button === scope.mouseButtons.ZOOM ) {

  				if ( scope.enableZoom === false ) return;

  				handleMouseDownDolly( event );

  				state = STATE.DOLLY;

  			} else if ( event.button === scope.mouseButtons.PAN ) {

  				if ( scope.enablePan === false ) return;

  				handleMouseDownPan( event );

  				state = STATE.PAN;

  			}

  			if ( state !== STATE.NONE ) {

  				document.addEventListener( 'mousemove', onMouseMove, false );
  				document.addEventListener( 'mouseup', onMouseUp, false );

  				scope.dispatchEvent( startEvent );

  			}

  		}

  		function onMouseMove( event ) {

  			if ( scope.enabled === false ) return;

  			event.preventDefault();

  			if ( state === STATE.ROTATE ) {

  				if ( scope.enableRotate === false ) return;

  				handleMouseMoveRotate( event );

  			} else if ( state === STATE.DOLLY ) {

  				if ( scope.enableZoom === false ) return;

  				handleMouseMoveDolly( event );

  			} else if ( state === STATE.PAN ) {

  				if ( scope.enablePan === false ) return;

  				handleMouseMovePan( event );

  			}

  		}

  		function onMouseUp( event ) {

  			if ( scope.enabled === false ) return;

  			document.removeEventListener( 'mousemove', onMouseMove, false );
  			document.removeEventListener( 'mouseup', onMouseUp, false );

  			scope.dispatchEvent( endEvent );

  			state = STATE.NONE;

  		}

  		function onMouseWheel( event ) {

  			if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

  			event.preventDefault();
  			event.stopPropagation();

  			handleMouseWheel( event );

  			scope.dispatchEvent( startEvent ); // not sure why these are here...
  			scope.dispatchEvent( endEvent );

  		}

  		function onKeyDown( event ) {

  			if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

  			handleKeyDown( event );

  		}

  		function onTouchStart( event ) {

  			if ( scope.enabled === false ) return;

  			switch ( event.touches.length ) {

  				case 1:	// one-fingered touch: rotate

  					if ( scope.enableRotate === false ) return;

  					handleTouchStartRotate( event );

  					state = STATE.TOUCH_ROTATE;

  					break;

  				case 2:	// two-fingered touch: dolly

  					if ( scope.enableZoom === false ) return;

  					handleTouchStartDolly( event );

  					state = STATE.TOUCH_DOLLY;

  					break;

  				case 3: // three-fingered touch: pan

  					if ( scope.enablePan === false ) return;

  					handleTouchStartPan( event );

  					state = STATE.TOUCH_PAN;

  					break;

  				default:

  					state = STATE.NONE;

  			}

  			if ( state !== STATE.NONE ) {

  				scope.dispatchEvent( startEvent );

  			}

  		}

  		function onTouchMove( event ) {

  			if ( scope.enabled === false ) return;

  			event.preventDefault();
  			event.stopPropagation();

  			switch ( event.touches.length ) {

  				case 1: // one-fingered touch: rotate

  					if ( scope.enableRotate === false ) return;
  					if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...

  					handleTouchMoveRotate( event );

  					break;

  				case 2: // two-fingered touch: dolly

  					if ( scope.enableZoom === false ) return;
  					if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...

  					handleTouchMoveDolly( event );

  					break;

  				case 3: // three-fingered touch: pan

  					if ( scope.enablePan === false ) return;
  					if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...

  					handleTouchMovePan( event );

  					break;

  				default:

  					state = STATE.NONE;

  			}

  		}

  		function onTouchEnd( event ) {

  			if ( scope.enabled === false ) return;

  			scope.dispatchEvent( endEvent );

  			state = STATE.NONE;

  		}

  		function onContextMenu( event ) {

  			event.preventDefault();

  		}

  		//

  		scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

  		scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
  		scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

  		scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
  		scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
  		scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

  		window.addEventListener( 'keydown', onKeyDown, false );

  		// force an update at start

  		this.update();

  	}
  	OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
  	OrbitControls.prototype.constructor = OrbitControls;

  	Object.defineProperties( OrbitControls.prototype, {

  		center: {

  			get: function () {

  				console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
  				return this.target;

  			}

  		},

  		// backward compatibility

  		noZoom: {

  			get: function () {

  				console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
  				return ! this.enableZoom;

  			},

  			set: function ( value ) {

  				console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
  				this.enableZoom = ! value;

  			}

  		},

  		noRotate: {

  			get: function () {

  				console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
  				return ! this.enableRotate;

  			},

  			set: function ( value ) {

  				console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
  				this.enableRotate = ! value;

  			}

  		},

  		noPan: {

  			get: function () {

  				console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
  				return ! this.enablePan;

  			},

  			set: function ( value ) {

  				console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
  				this.enablePan = ! value;

  			}

  		},

  		noKeys: {

  			get: function () {

  				console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
  				return ! this.enableKeys;

  			},

  			set: function ( value ) {

  				console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
  				this.enableKeys = ! value;

  			}

  		},

  		staticMoving : {

  			get: function () {

  				console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
  				return ! this.enableDamping;

  			},

  			set: function ( value ) {

  				console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
  				this.enableDamping = ! value;

  			}

  		},

  		dynamicDampingFactor : {

  			get: function () {

  				console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
  				return this.dampingFactor;

  			},

  			set: function ( value ) {

  				console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
  				this.dampingFactor = value;

  			}

  		}

  	} );

  	return OrbitControls;
  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author paulirish / http://paulirish.com/
   */


  var threeFlyControls = function(THREE) {

      THREE.FlyControls = function ( object, domElement, opts ) {

          this.object = object;

          opts = opts || {};

          this.domElement = ( domElement !== undefined ) ? domElement : document;
          if ( domElement ) this.domElement.setAttribute( 'tabindex', -1 );

          // API

          this.movementSpeed = (opts.movementSpeed === undefined) ? 1.0 : opts.movementSpeed;
          this.rollSpeed = (opts.rollSpeed === undefined) ? 0.005 : opts.rollSpeed;

          this.dragToLook = true;
          this.autoForward = false;

          // disable default target object behavior

          // internals

          this.tmpQuaternion = new THREE.Quaternion();

          this.mouseStatus = 0;

          this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
          this.moveVector = new THREE.Vector3( 0, 0, 0 );
          this.rotationVector = new THREE.Vector3( 0, 0, 0 );

          var prevTime = Date.now();


          this.handleEvent = function ( event ) {

              if ( typeof this[ event.type ] == 'function' ) {

                  this[ event.type ]( event );

              }

          };

          this.keydown = function( event ) {

              if ( event.altKey ) {

                  return;

              }

              

              switch ( event.keyCode ) {

                  case 16: /* shift */ this.movementSpeedMultiplier = .1; break;

                  case 87: /*W*/ this.moveState.forward = 1; break;
                  case 83: /*S*/ this.moveState.back = 1; break;

                  case 65: /*A*/ this.moveState.left = 1; break;
                  case 68: /*D*/ this.moveState.right = 1; break;

                  case 82: /*R*/ this.moveState.up = 1; break;
                  case 70: /*F*/ this.moveState.down = 1; break;

                  case 38: /*up*/ this.moveState.pitchUp = 1; break;
                  case 40: /*down*/ this.moveState.pitchDown = 1; break;

                  case 37: /*left*/ this.moveState.yawLeft = 1; break;
                  case 39: /*right*/ this.moveState.yawRight = 1; break;

                  case 81: /*Q*/ this.moveState.rollLeft = 1; break;
                  case 69: /*E*/ this.moveState.rollRight = 1; break;

              }
              
              var surpress = [38, 40, 37, 39];

              if(surpress.indexOf(event.keyCode) > -1) {
                  event.preventDefault();
              }

              this.updateMovementVector();
              this.updateRotationVector();

          };

          this.keyup = function( event ) {

              switch( event.keyCode ) {

                  case 16: /* shift */ this.movementSpeedMultiplier = 1; break;

                  case 87: /*W*/ this.moveState.forward = 0; break;
                  case 83: /*S*/ this.moveState.back = 0; break;

                  case 65: /*A*/ this.moveState.left = 0; break;
                  case 68: /*D*/ this.moveState.right = 0; break;

                  case 82: /*R*/ this.moveState.up = 0; break;
                  case 70: /*F*/ this.moveState.down = 0; break;

                  case 38: /*up*/ this.moveState.pitchUp = 0; break;
                  case 40: /*down*/ this.moveState.pitchDown = 0; break;

                  case 37: /*left*/ this.moveState.yawLeft = 0; break;
                  case 39: /*right*/ this.moveState.yawRight = 0; break;

                  case 81: /*Q*/ this.moveState.rollLeft = 0; break;
                  case 69: /*E*/ this.moveState.rollRight = 0; break;

              }

              this.updateMovementVector();
              this.updateRotationVector();

          };

          this.mousedown = function( event ) {

              if ( this.domElement !== document ) {

                  this.domElement.focus();

              }

              event.preventDefault();
              event.stopPropagation();

              if ( this.dragToLook ) {

                  this.mouseStatus ++;

              } else {

                  switch ( event.button ) {

                      case 0: this.moveState.forward = 1; break;
                      case 2: this.moveState.back = 1; break;

                  }

                  this.updateMovementVector();

              }

          };

          this.mousemove = function( event ) {

              if ( !this.dragToLook || this.mouseStatus > 0 ) {

                  var container = this.getContainerDimensions();
                  var halfWidth  = container.size[ 0 ] / 2;
                  var halfHeight = container.size[ 1 ] / 2;

                  this.moveState.yawLeft   = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth  ) / halfWidth;
                  this.moveState.pitchDown =   ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;

                  this.updateRotationVector();

              }

          };


          this.mouseout = function( event ) {

              event.preventDefault();
              event.stopPropagation();
              this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
              this.updateRotationVector();
              this.updateMovementVector();
          };

          this.mouseup = function( event ) {

              event.preventDefault();
              event.stopPropagation();

              if ( this.dragToLook ) {

                  this.mouseStatus --;

                  this.moveState.yawLeft = this.moveState.pitchDown = 0;

              } else {

                  switch ( event.button ) {

                      case 0: this.moveState.forward = 0; break;
                      case 2: this.moveState.back = 0; break;

                  }

                  this.updateMovementVector();

              }

              this.updateRotationVector();

          };

          this.update = function( delta ) {
              
              var time = Date.now();
              var delta = ( time - prevTime ) / 10;

              var moveMult = delta * this.movementSpeed;
              var rotMult = delta * this.rollSpeed;

              this.object.translateX( this.moveVector.x * moveMult );
              this.object.translateY( this.moveVector.y * moveMult );
              this.object.translateZ( this.moveVector.z * moveMult );

              this.tmpQuaternion.set( this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1 ).normalize();
              this.object.quaternion.multiply( this.tmpQuaternion );

              // expose the rotation vector for convenience
              this.object.rotation.setFromQuaternion( this.object.quaternion, this.object.rotation.order );

              prevTime = time;
          };

          this.updateMovementVector = function() {

              var forward = ( this.moveState.forward || ( this.autoForward && !this.moveState.back ) ) ? 1 : 0;

              this.moveVector.x = ( -this.moveState.left    + this.moveState.right );
              this.moveVector.y = ( -this.moveState.down    + this.moveState.up );
              this.moveVector.z = ( -forward + this.moveState.back );

              //console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );

          };

          this.updateRotationVector = function() {

              this.rotationVector.x = ( -this.moveState.pitchDown + this.moveState.pitchUp );
              this.rotationVector.y = ( -this.moveState.yawRight  + this.moveState.yawLeft );
              this.rotationVector.z = ( -this.moveState.rollRight + this.moveState.rollLeft );

              //console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );

          };

          this.getContainerDimensions = function() {

              if ( this.domElement != document ) {

                  return {
                      size    : [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
                      offset  : [ this.domElement.offsetLeft,  this.domElement.offsetTop ]
                  };

              } else {

                  return {
                      size    : [ window.innerWidth, window.innerHeight ],
                      offset  : [ 0, 0 ]
                  };

              }

          };



          function bind( scope, fn ) {

              return function () {

                  fn.apply( scope, arguments );

              };

          }
          this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

          this.domElement.addEventListener( 'mousemove', bind( this, this.mousemove ), false );
          this.domElement.addEventListener( 'mousedown', bind( this, this.mousedown ), false );
          this.domElement.addEventListener( 'mouseup',   bind( this, this.mouseup ), false );
          this.domElement.addEventListener( 'mouseout',   bind( this, this.mouseout ), false );

          this.domElement.addEventListener( 'keydown', bind( this, this.keydown ), false );
          this.domElement.addEventListener( 'keyup',   bind( this, this.keyup ), false );

          this.updateMovementVector();
          this.updateRotationVector();
      };

  };

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  // based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js

  /**
   * Parse errors.md and turn it into a simple hash of code: message
   * @private
   */
  var ERRORS = {
    "1": "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
    "2": "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
    "3": "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
    "4": "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
    "5": "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
    "6": "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
    "7": "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
    "8": "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
    "9": "Please provide a number of steps to the modularScale helper.\n\n",
    "10": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
    "11": "Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\n\n",
    "12": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\n\n",
    "13": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\n\n",
    "14": "Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
    "15": "Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\n\n",
    "16": "You must provide a template to this method.\n\n",
    "17": "You passed an unsupported selector state to this method.\n\n",
    "18": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
    "19": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
    "20": "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
    "21": "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    "22": "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
    "23": "fontFace expects a name of a font-family.\n\n",
    "24": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
    "25": "fontFace expects localFonts to be an array.\n\n",
    "26": "fontFace expects fileFormats to be an array.\n\n",
    "27": "radialGradient requries at least 2 color-stops to properly render.\n\n",
    "28": "Please supply a filename to retinaImage() as the first argument.\n\n",
    "29": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
    "30": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    "31": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
    "32": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
    "33": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
    "34": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
    "35": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
    "36": "Property must be a string value.\n\n",
    "37": "Syntax Error at %s.\n\n",
    "38": "Formula contains a function that needs parentheses at %s.\n\n",
    "39": "Formula is missing closing parenthesis at %s.\n\n",
    "40": "Formula has too many closing parentheses at %s.\n\n",
    "41": "All values in a formula must have the same unit or be unitless.\n\n",
    "42": "Please provide a number of steps to the modularScale helper.\n\n",
    "43": "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
    "44": "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
    "45": "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
    "46": "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
    "47": "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
    "48": "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
    "49": "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
    "50": "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
    "51": "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
    "52": "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
    "53": "fontFace expects localFonts to be an array.\n\n",
    "54": "fontFace expects fileFormats to be an array.\n\n",
    "55": "fontFace expects a name of a font-family.\n\n",
    "56": "linearGradient requries at least 2 color-stops to properly render.\n\n",
    "57": "radialGradient requries at least 2 color-stops to properly render.\n\n",
    "58": "Please supply a filename to retinaImage() as the first argument.\n\n",
    "59": "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
    "60": "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
    "61": "Property must be a string value.\n\n",
    "62": "borderRadius expects a radius value as a string or number as the second argument.\n\n",
    "63": "borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\n\n",
    "64": "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
    "65": "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
    "66": "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
    "67": "You must provide a template to this method.\n\n",
    "68": "You passed an unsupported selector state to this method.\n\n",
    "69": "Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\n\n",
    "70": "Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\n\n",
    "71": "Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\n\n",
    "72": "Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\n"
  };
  /**
   * super basic version of sprintf
   * @private
   */

  function format() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var a = args[0];
    var b = [];
    var c;

    for (c = 1; c < args.length; c += 1) {
      b.push(args[c]);
    }

    b.forEach(function (d) {
      a = a.replace(/%[a-z]/, d);
    });
    return a;
  }
  /**
   * Create an error file out of errors.md for development and a simple web link to the full errors
   * in production mode.
   * @private
   */


  var PolishedError =
  /*#__PURE__*/
  function (_Error) {
    _inheritsLoose(PolishedError, _Error);

    function PolishedError(code) {
      var _this;

      if (process.env.NODE_ENV === 'production') {
        _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/master/src/internalHelpers/errors.md#" + code + " for more information.") || this;
      } else {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        _this = _Error.call(this, format.apply(void 0, [ERRORS[code]].concat(args))) || this;
      }

      return _assertThisInitialized(_this);
    }

    return PolishedError;
  }(
  /*#__PURE__*/
  _wrapNativeSuper(Error));

  function colorToInt(color) {
    return Math.round(color * 255);
  }

  function convertToInt(red, green, blue) {
    return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
  }

  function hslToRgb(hue, saturation, lightness, convert) {
    if (convert === void 0) {
      convert = convertToInt;
    }

    if (saturation === 0) {
      // achromatic
      return convert(lightness, lightness, lightness);
    } // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV


    var huePrime = (hue % 360 + 360) % 360 / 60;
    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
    var red = 0;
    var green = 0;
    var blue = 0;

    if (huePrime >= 0 && huePrime < 1) {
      red = chroma;
      green = secondComponent;
    } else if (huePrime >= 1 && huePrime < 2) {
      red = secondComponent;
      green = chroma;
    } else if (huePrime >= 2 && huePrime < 3) {
      green = chroma;
      blue = secondComponent;
    } else if (huePrime >= 3 && huePrime < 4) {
      green = secondComponent;
      blue = chroma;
    } else if (huePrime >= 4 && huePrime < 5) {
      red = secondComponent;
      blue = chroma;
    } else if (huePrime >= 5 && huePrime < 6) {
      red = chroma;
      blue = secondComponent;
    }

    var lightnessModification = lightness - chroma / 2;
    var finalRed = red + lightnessModification;
    var finalGreen = green + lightnessModification;
    var finalBlue = blue + lightnessModification;
    return convert(finalRed, finalGreen, finalBlue);
  }

  var namedColorMap = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '00ffff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000',
    blanchedalmond: 'ffebcd',
    blue: '0000ff',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '00ffff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkgrey: 'a9a9a9',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'ff00ff',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    grey: '808080',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgreen: '90ee90',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslategray: '789',
    lightslategrey: '789',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '0f0',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'f0f',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370db',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'db7093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    rebeccapurple: '639',
    red: 'f00',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    slategrey: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    wheat: 'f5deb3',
    white: 'fff',
    whitesmoke: 'f5f5f5',
    yellow: 'ff0',
    yellowgreen: '9acd32'
  };
  /**
   * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
   * @private
   */

  function nameToHex(color) {
    if (typeof color !== 'string') return color;
    var normalizedColorName = color.toLowerCase();
    return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
  }

  var hexRegex = /^#[a-fA-F0-9]{6}$/;
  var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
  var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
  var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
  var rgbRegex = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i;
  var rgbaRegex = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
  var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
  var hslaRegex = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
  /**
   * Returns an RgbColor or RgbaColor object. This utility function is only useful
   * if want to extract a color component. With the color util `toColorString` you
   * can convert a RgbColor or RgbaColor object back to a string.
   *
   * @example
   * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
   * const color1 = parseToRgb('rgb(255, 0, 0)');
   * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
   * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');
   */

  function parseToRgb(color) {
    if (typeof color !== 'string') {
      throw new PolishedError(3);
    }

    var normalizedColor = nameToHex(color);

    if (normalizedColor.match(hexRegex)) {
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
      };
    }

    if (normalizedColor.match(hexRgbaRegex)) {
      var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
        green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
        blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
        alpha: alpha
      };
    }

    if (normalizedColor.match(reducedHexRegex)) {
      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
      };
    }

    if (normalizedColor.match(reducedRgbaHexRegex)) {
      var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));

      return {
        red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
        green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
        blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
        alpha: _alpha
      };
    }

    var rgbMatched = rgbRegex.exec(normalizedColor);

    if (rgbMatched) {
      return {
        red: parseInt("" + rgbMatched[1], 10),
        green: parseInt("" + rgbMatched[2], 10),
        blue: parseInt("" + rgbMatched[3], 10)
      };
    }

    var rgbaMatched = rgbaRegex.exec(normalizedColor);

    if (rgbaMatched) {
      return {
        red: parseInt("" + rgbaMatched[1], 10),
        green: parseInt("" + rgbaMatched[2], 10),
        blue: parseInt("" + rgbaMatched[3], 10),
        alpha: parseFloat("" + rgbaMatched[4])
      };
    }

    var hslMatched = hslRegex.exec(normalizedColor);

    if (hslMatched) {
      var hue = parseInt("" + hslMatched[1], 10);
      var saturation = parseInt("" + hslMatched[2], 10) / 100;
      var lightness = parseInt("" + hslMatched[3], 10) / 100;
      var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
      var hslRgbMatched = rgbRegex.exec(rgbColorString);

      if (!hslRgbMatched) {
        throw new PolishedError(4, normalizedColor, rgbColorString);
      }

      return {
        red: parseInt("" + hslRgbMatched[1], 10),
        green: parseInt("" + hslRgbMatched[2], 10),
        blue: parseInt("" + hslRgbMatched[3], 10)
      };
    }

    var hslaMatched = hslaRegex.exec(normalizedColor);

    if (hslaMatched) {
      var _hue = parseInt("" + hslaMatched[1], 10);

      var _saturation = parseInt("" + hslaMatched[2], 10) / 100;

      var _lightness = parseInt("" + hslaMatched[3], 10) / 100;

      var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";

      var _hslRgbMatched = rgbRegex.exec(_rgbColorString);

      if (!_hslRgbMatched) {
        throw new PolishedError(4, normalizedColor, _rgbColorString);
      }

      return {
        red: parseInt("" + _hslRgbMatched[1], 10),
        green: parseInt("" + _hslRgbMatched[2], 10),
        blue: parseInt("" + _hslRgbMatched[3], 10),
        alpha: parseFloat("" + hslaMatched[4])
      };
    }

    throw new PolishedError(5);
  }

  /**
   * Reduces hex values if possible e.g. #ff8866 to #f86
   * @private
   */
  var reduceHexValue = function reduceHexValue(value) {
    if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
      return "#" + value[1] + value[3] + value[5];
    }

    return value;
  };

  function numberToHex(value) {
    var hex = value.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }

  function rgb(value, green, blue) {
    if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
      return reduceHexValue("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
    } else if (typeof value === 'object' && green === undefined && blue === undefined) {
      return reduceHexValue("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
    }

    throw new PolishedError(6);
  }

  function rgba(firstValue, secondValue, thirdValue, fourthValue) {
    if (typeof firstValue === 'string' && typeof secondValue === 'number') {
      var rgbValue = parseToRgb(firstValue);
      return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
    } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {
      return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
    } else if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
      return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
    }

    throw new PolishedError(7);
  }

  // Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js
  // eslint-disable-next-line no-unused-vars
  // eslint-disable-next-line no-unused-vars
  // eslint-disable-next-line no-redeclare
  function curried(f, length, acc) {
    return function fn() {
      // eslint-disable-next-line prefer-rest-params
      var combined = acc.concat(Array.prototype.slice.call(arguments));
      return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
    };
  } // eslint-disable-next-line no-redeclare


  function curry(f) {
    // eslint-disable-line no-redeclare
    return curried(f, f.length, []);
  }

  function guard(lowerBoundary, upperBoundary, value) {
    return Math.max(lowerBoundary, Math.min(upperBoundary, value));
  }

  /**
   * Increases the opacity of a color. Its range for the amount is between 0 to 1.
   *
   *
   * @example
   * // Styles as object usage
   * const styles = {
   *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');
   *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),
   *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),
   * }
   *
   * // styled-components usage
   * const div = styled.div`
   *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};
   *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},
   *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},
   * `
   *
   * // CSS in JS Output
   *
   * element {
   *   background: "#fff";
   *   background: "rgba(255,255,255,0.7)";
   *   background: "rgba(255,0,0,0.7)";
   * }
   */

  function opacify(amount, color) {
    if (color === 'transparent') return color;
    var parsedColor = parseToRgb(color);
    var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;

    var colorWithAlpha = _extends({}, parsedColor, {
      alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
    });

    return rgba(colorWithAlpha);
  } // prettier-ignore


  var curriedOpacify =
  /*#__PURE__*/
  curry
  /* ::<number | string, string, string> */
  (opacify);

  const version = '18.4.2';

  /**
   * Tween.js - Licensed under the MIT license
   * https://github.com/tweenjs/tween.js
   * ----------------------------------------------
   *
   * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
   * Thank you all, you're awesome!
   */


  var _Group = function () {
  	this._tweens = {};
  	this._tweensAddedDuringUpdate = {};
  };

  _Group.prototype = {
  	getAll: function () {

  		return Object.keys(this._tweens).map(function (tweenId) {
  			return this._tweens[tweenId];
  		}.bind(this));

  	},

  	removeAll: function () {

  		this._tweens = {};

  	},

  	add: function (tween) {

  		this._tweens[tween.getId()] = tween;
  		this._tweensAddedDuringUpdate[tween.getId()] = tween;

  	},

  	remove: function (tween) {

  		delete this._tweens[tween.getId()];
  		delete this._tweensAddedDuringUpdate[tween.getId()];

  	},

  	update: function (time, preserve) {

  		var tweenIds = Object.keys(this._tweens);

  		if (tweenIds.length === 0) {
  			return false;
  		}

  		time = time !== undefined ? time : TWEEN.now();

  		// Tweens are updated in "batches". If you add a new tween during an
  		// update, then the new tween will be updated in the next batch.
  		// If you remove a tween during an update, it may or may not be updated.
  		// However, if the removed tween was added during the current batch,
  		// then it will not be updated.
  		while (tweenIds.length > 0) {
  			this._tweensAddedDuringUpdate = {};

  			for (var i = 0; i < tweenIds.length; i++) {

  				var tween = this._tweens[tweenIds[i]];

  				if (tween && tween.update(time) === false) {
  					tween._isPlaying = false;

  					if (!preserve) {
  						delete this._tweens[tweenIds[i]];
  					}
  				}
  			}

  			tweenIds = Object.keys(this._tweensAddedDuringUpdate);
  		}

  		return true;

  	}
  };

  var TWEEN = new _Group();

  TWEEN.Group = _Group;
  TWEEN._nextId = 0;
  TWEEN.nextId = function () {
  	return TWEEN._nextId++;
  };


  // Include a performance.now polyfill.
  // In node.js, use process.hrtime.
  if (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {
  	TWEEN.now = function () {
  		var time = process.hrtime();

  		// Convert [seconds, nanoseconds] to milliseconds.
  		return time[0] * 1000 + time[1] / 1000000;
  	};
  }
  // In a browser, use self.performance.now if it is available.
  else if (typeof (self) !== 'undefined' &&
           self.performance !== undefined &&
  		 self.performance.now !== undefined) {
  	// This must be bound, because directly assigning this function
  	// leads to an invocation exception in Chrome.
  	TWEEN.now = self.performance.now.bind(self.performance);
  }
  // Use Date.now if it is available.
  else if (Date.now !== undefined) {
  	TWEEN.now = Date.now;
  }
  // Otherwise, use 'new Date().getTime()'.
  else {
  	TWEEN.now = function () {
  		return new Date().getTime();
  	};
  }


  TWEEN.Tween = function (object, group) {
  	this._isPaused = false;
  	this._pauseStart = null;
  	this._object = object;
  	this._valuesStart = {};
  	this._valuesEnd = {};
  	this._valuesStartRepeat = {};
  	this._duration = 1000;
  	this._repeat = 0;
  	this._repeatDelayTime = undefined;
  	this._yoyo = false;
  	this._isPlaying = false;
  	this._reversed = false;
  	this._delayTime = 0;
  	this._startTime = null;
  	this._easingFunction = TWEEN.Easing.Linear.None;
  	this._interpolationFunction = TWEEN.Interpolation.Linear;
  	this._chainedTweens = [];
  	this._onStartCallback = null;
  	this._onStartCallbackFired = false;
  	this._onUpdateCallback = null;
  	this._onRepeatCallback = null;
  	this._onCompleteCallback = null;
  	this._onStopCallback = null;
  	this._group = group || TWEEN;
  	this._id = TWEEN.nextId();

  };

  TWEEN.Tween.prototype = {
  	getId: function () {
  		return this._id;
  	},

  	isPlaying: function () {
  		return this._isPlaying;
  	},

  	isPaused: function () {
  		return this._isPaused;
  	},

  	to: function (properties, duration) {

  		this._valuesEnd = Object.create(properties);

  		if (duration !== undefined) {
  			this._duration = duration;
  		}

  		return this;

  	},

  	duration: function duration(d) {
  		this._duration = d;
  		return this;
  	},

  	start: function (time) {

  		this._group.add(this);

  		this._isPlaying = true;

  		this._isPaused = false;

  		this._onStartCallbackFired = false;

  		this._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();
  		this._startTime += this._delayTime;

  		for (var property in this._valuesEnd) {

  			// Check if an Array was provided as property value
  			if (this._valuesEnd[property] instanceof Array) {

  				if (this._valuesEnd[property].length === 0) {
  					continue;
  				}

  				// Create a local copy of the Array with the start value at the front
  				this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);

  			}

  			// If `to()` specifies a property that doesn't exist in the source object,
  			// we should not set that property in the object
  			if (this._object[property] === undefined) {
  				continue;
  			}

  			// Save the starting value, but only once.
  			if (typeof(this._valuesStart[property]) === 'undefined') {
  				this._valuesStart[property] = this._object[property];
  			}

  			if ((this._valuesStart[property] instanceof Array) === false) {
  				this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
  			}

  			this._valuesStartRepeat[property] = this._valuesStart[property] || 0;

  		}

  		return this;

  	},

  	stop: function () {

  		if (!this._isPlaying) {
  			return this;
  		}

  		this._group.remove(this);

  		this._isPlaying = false;

  		this._isPaused = false;

  		if (this._onStopCallback !== null) {
  			this._onStopCallback(this._object);
  		}

  		this.stopChainedTweens();
  		return this;

  	},

  	end: function () {

  		this.update(Infinity);
  		return this;

  	},

  	pause: function(time) {

  		if (this._isPaused || !this._isPlaying) {
  			return this;
  		}

  		this._isPaused = true;

  		this._pauseStart = time === undefined ? TWEEN.now() : time;

  		this._group.remove(this);

  		return this;

  	},

  	resume: function(time) {

  		if (!this._isPaused || !this._isPlaying) {
  			return this;
  		}

  		this._isPaused = false;

  		this._startTime += (time === undefined ? TWEEN.now() : time)
  			- this._pauseStart;

  		this._pauseStart = 0;

  		this._group.add(this);

  		return this;

  	},

  	stopChainedTweens: function () {

  		for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
  			this._chainedTweens[i].stop();
  		}

  	},

  	group: function (group) {
  		this._group = group;
  		return this;
  	},

  	delay: function (amount) {

  		this._delayTime = amount;
  		return this;

  	},

  	repeat: function (times) {

  		this._repeat = times;
  		return this;

  	},

  	repeatDelay: function (amount) {

  		this._repeatDelayTime = amount;
  		return this;

  	},

  	yoyo: function (yoyo) {

  		this._yoyo = yoyo;
  		return this;

  	},

  	easing: function (easingFunction) {

  		this._easingFunction = easingFunction;
  		return this;

  	},

  	interpolation: function (interpolationFunction) {

  		this._interpolationFunction = interpolationFunction;
  		return this;

  	},

  	chain: function () {

  		this._chainedTweens = arguments;
  		return this;

  	},

  	onStart: function (callback) {

  		this._onStartCallback = callback;
  		return this;

  	},

  	onUpdate: function (callback) {

  		this._onUpdateCallback = callback;
  		return this;

  	},

  	onRepeat: function onRepeat(callback) {

  		this._onRepeatCallback = callback;
  		return this;

  	},

  	onComplete: function (callback) {

  		this._onCompleteCallback = callback;
  		return this;

  	},

  	onStop: function (callback) {

  		this._onStopCallback = callback;
  		return this;

  	},

  	update: function (time) {

  		var property;
  		var elapsed;
  		var value;

  		if (time < this._startTime) {
  			return true;
  		}

  		if (this._onStartCallbackFired === false) {

  			if (this._onStartCallback !== null) {
  				this._onStartCallback(this._object);
  			}

  			this._onStartCallbackFired = true;
  		}

  		elapsed = (time - this._startTime) / this._duration;
  		elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;

  		value = this._easingFunction(elapsed);

  		for (property in this._valuesEnd) {

  			// Don't update properties that do not exist in the source object
  			if (this._valuesStart[property] === undefined) {
  				continue;
  			}

  			var start = this._valuesStart[property] || 0;
  			var end = this._valuesEnd[property];

  			if (end instanceof Array) {

  				this._object[property] = this._interpolationFunction(end, value);

  			} else {

  				// Parses relative end values with start as base (e.g.: +10, -3)
  				if (typeof (end) === 'string') {

  					if (end.charAt(0) === '+' || end.charAt(0) === '-') {
  						end = start + parseFloat(end);
  					} else {
  						end = parseFloat(end);
  					}
  				}

  				// Protect against non numeric properties.
  				if (typeof (end) === 'number') {
  					this._object[property] = start + (end - start) * value;
  				}

  			}

  		}

  		if (this._onUpdateCallback !== null) {
  			this._onUpdateCallback(this._object, elapsed);
  		}

  		if (elapsed === 1) {

  			if (this._repeat > 0) {

  				if (isFinite(this._repeat)) {
  					this._repeat--;
  				}

  				// Reassign starting values, restart by making startTime = now
  				for (property in this._valuesStartRepeat) {

  					if (typeof (this._valuesEnd[property]) === 'string') {
  						this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
  					}

  					if (this._yoyo) {
  						var tmp = this._valuesStartRepeat[property];

  						this._valuesStartRepeat[property] = this._valuesEnd[property];
  						this._valuesEnd[property] = tmp;
  					}

  					this._valuesStart[property] = this._valuesStartRepeat[property];

  				}

  				if (this._yoyo) {
  					this._reversed = !this._reversed;
  				}

  				if (this._repeatDelayTime !== undefined) {
  					this._startTime = time + this._repeatDelayTime;
  				} else {
  					this._startTime = time + this._delayTime;
  				}

  				if (this._onRepeatCallback !== null) {
  					this._onRepeatCallback(this._object);
  				}

  				return true;

  			} else {

  				if (this._onCompleteCallback !== null) {

  					this._onCompleteCallback(this._object);
  				}

  				for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
  					// Make the chained tweens start exactly at the time they should,
  					// even if the `update()` method was called way past the duration of the tween
  					this._chainedTweens[i].start(this._startTime + this._duration);
  				}

  				return false;

  			}

  		}

  		return true;

  	}
  };


  TWEEN.Easing = {

  	Linear: {

  		None: function (k) {

  			return k;

  		}

  	},

  	Quadratic: {

  		In: function (k) {

  			return k * k;

  		},

  		Out: function (k) {

  			return k * (2 - k);

  		},

  		InOut: function (k) {

  			if ((k *= 2) < 1) {
  				return 0.5 * k * k;
  			}

  			return - 0.5 * (--k * (k - 2) - 1);

  		}

  	},

  	Cubic: {

  		In: function (k) {

  			return k * k * k;

  		},

  		Out: function (k) {

  			return --k * k * k + 1;

  		},

  		InOut: function (k) {

  			if ((k *= 2) < 1) {
  				return 0.5 * k * k * k;
  			}

  			return 0.5 * ((k -= 2) * k * k + 2);

  		}

  	},

  	Quartic: {

  		In: function (k) {

  			return k * k * k * k;

  		},

  		Out: function (k) {

  			return 1 - (--k * k * k * k);

  		},

  		InOut: function (k) {

  			if ((k *= 2) < 1) {
  				return 0.5 * k * k * k * k;
  			}

  			return - 0.5 * ((k -= 2) * k * k * k - 2);

  		}

  	},

  	Quintic: {

  		In: function (k) {

  			return k * k * k * k * k;

  		},

  		Out: function (k) {

  			return --k * k * k * k * k + 1;

  		},

  		InOut: function (k) {

  			if ((k *= 2) < 1) {
  				return 0.5 * k * k * k * k * k;
  			}

  			return 0.5 * ((k -= 2) * k * k * k * k + 2);

  		}

  	},

  	Sinusoidal: {

  		In: function (k) {

  			return 1 - Math.cos(k * Math.PI / 2);

  		},

  		Out: function (k) {

  			return Math.sin(k * Math.PI / 2);

  		},

  		InOut: function (k) {

  			return 0.5 * (1 - Math.cos(Math.PI * k));

  		}

  	},

  	Exponential: {

  		In: function (k) {

  			return k === 0 ? 0 : Math.pow(1024, k - 1);

  		},

  		Out: function (k) {

  			return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);

  		},

  		InOut: function (k) {

  			if (k === 0) {
  				return 0;
  			}

  			if (k === 1) {
  				return 1;
  			}

  			if ((k *= 2) < 1) {
  				return 0.5 * Math.pow(1024, k - 1);
  			}

  			return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);

  		}

  	},

  	Circular: {

  		In: function (k) {

  			return 1 - Math.sqrt(1 - k * k);

  		},

  		Out: function (k) {

  			return Math.sqrt(1 - (--k * k));

  		},

  		InOut: function (k) {

  			if ((k *= 2) < 1) {
  				return - 0.5 * (Math.sqrt(1 - k * k) - 1);
  			}

  			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);

  		}

  	},

  	Elastic: {

  		In: function (k) {

  			if (k === 0) {
  				return 0;
  			}

  			if (k === 1) {
  				return 1;
  			}

  			return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);

  		},

  		Out: function (k) {

  			if (k === 0) {
  				return 0;
  			}

  			if (k === 1) {
  				return 1;
  			}

  			return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;

  		},

  		InOut: function (k) {

  			if (k === 0) {
  				return 0;
  			}

  			if (k === 1) {
  				return 1;
  			}

  			k *= 2;

  			if (k < 1) {
  				return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
  			}

  			return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;

  		}

  	},

  	Back: {

  		In: function (k) {

  			var s = 1.70158;

  			return k * k * ((s + 1) * k - s);

  		},

  		Out: function (k) {

  			var s = 1.70158;

  			return --k * k * ((s + 1) * k + s) + 1;

  		},

  		InOut: function (k) {

  			var s = 1.70158 * 1.525;

  			if ((k *= 2) < 1) {
  				return 0.5 * (k * k * ((s + 1) * k - s));
  			}

  			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);

  		}

  	},

  	Bounce: {

  		In: function (k) {

  			return 1 - TWEEN.Easing.Bounce.Out(1 - k);

  		},

  		Out: function (k) {

  			if (k < (1 / 2.75)) {
  				return 7.5625 * k * k;
  			} else if (k < (2 / 2.75)) {
  				return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
  			} else if (k < (2.5 / 2.75)) {
  				return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
  			} else {
  				return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
  			}

  		},

  		InOut: function (k) {

  			if (k < 0.5) {
  				return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
  			}

  			return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

  		}

  	}

  };

  TWEEN.Interpolation = {

  	Linear: function (v, k) {

  		var m = v.length - 1;
  		var f = m * k;
  		var i = Math.floor(f);
  		var fn = TWEEN.Interpolation.Utils.Linear;

  		if (k < 0) {
  			return fn(v[0], v[1], f);
  		}

  		if (k > 1) {
  			return fn(v[m], v[m - 1], m - f);
  		}

  		return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

  	},

  	Bezier: function (v, k) {

  		var b = 0;
  		var n = v.length - 1;
  		var pw = Math.pow;
  		var bn = TWEEN.Interpolation.Utils.Bernstein;

  		for (var i = 0; i <= n; i++) {
  			b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
  		}

  		return b;

  	},

  	CatmullRom: function (v, k) {

  		var m = v.length - 1;
  		var f = m * k;
  		var i = Math.floor(f);
  		var fn = TWEEN.Interpolation.Utils.CatmullRom;

  		if (v[0] === v[m]) {

  			if (k < 0) {
  				i = Math.floor(f = m * (1 + k));
  			}

  			return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);

  		} else {

  			if (k < 0) {
  				return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
  			}

  			if (k > 1) {
  				return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
  			}

  			return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

  		}

  	},

  	Utils: {

  		Linear: function (p0, p1, t) {

  			return (p1 - p0) * t + p0;

  		},

  		Bernstein: function (n, i) {

  			var fc = TWEEN.Interpolation.Utils.Factorial;

  			return fc(n) / fc(i) / fc(n - i);

  		},

  		Factorial: (function () {

  			var a = [1];

  			return function (n) {

  				var s = 1;

  				if (a[n]) {
  					return a[n];
  				}

  				for (var i = n; i > 1; i--) {
  					s *= i;
  				}

  				a[n] = s;
  				return s;

  			};

  		})(),

  		CatmullRom: function (p0, p1, p2, p3, t) {

  			var v0 = (p2 - p0) * 0.5;
  			var v1 = (p3 - p1) * 0.5;
  			var t2 = t * t;
  			var t3 = t * t2;

  			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

  		}

  	}

  };
  TWEEN.version = version;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var accessor_min = createCommonjsModule(function (module, exports) {
  !function(e,t){module.exports=t();}(commonjsGlobal,function(){return function(e){function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o});},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=0)}([function(e,t,n){var o,r,u;!function(n,c){r=[e,t],void 0!==(u="function"==typeof(o=c)?o.apply(t,r):o)&&(e.exports=u);}(0,function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return e instanceof Function?e:"string"==typeof e?function(t){return t[e]}:function(t){return e}},e.exports=t.default;});}])});
  });

  var accessorFn = unwrapExports(accessor_min);
  var accessor_min_1 = accessor_min.accessorFn;

  /**
   * Returns a function, that, as long as it continues to be invoked, will not
   * be triggered. The function will be called after it stops being called for
   * N milliseconds. If `immediate` is passed, trigger the function on the
   * leading edge, instead of the trailing. The function also has a property 'clear' 
   * that is a function which will clear the timer to prevent previously scheduled executions. 
   *
   * @source underscore.js
   * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
   * @param {Function} function to wrap
   * @param {Number} timeout in ms (`100`)
   * @param {Boolean} whether to execute at the beginning (`false`)
   * @api public
   */
  function debounce(func, wait, immediate){
    var timeout, args, context, timestamp, result;
    if (null == wait) wait = 100;

    function later() {
      var last = Date.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    }
    var debounced = function(){
      context = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };

    debounced.clear = function() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    
    debounced.flush = function() {
      if (timeout) {
        result = func.apply(context, args);
        context = args = null;
        
        clearTimeout(timeout);
        timeout = null;
      }
    };

    return debounced;
  }
  // Adds compatibility for ES modules
  debounce.debounce = debounce;

  var debounce_1 = debounce;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var Prop = function Prop(name, _ref) {
    var _ref$default = _ref["default"],
        defaultVal = _ref$default === void 0 ? null : _ref$default,
        _ref$triggerUpdate = _ref.triggerUpdate,
        triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate,
        _ref$onChange = _ref.onChange,
        onChange = _ref$onChange === void 0 ? function (newVal, state) {} : _ref$onChange;

    _classCallCheck(this, Prop);

    this.name = name;
    this.defaultVal = defaultVal;
    this.triggerUpdate = triggerUpdate;
    this.onChange = onChange;
  };

  function index (_ref2) {
    var _ref2$stateInit = _ref2.stateInit,
        stateInit = _ref2$stateInit === void 0 ? function () {
      return {};
    } : _ref2$stateInit,
        _ref2$props = _ref2.props,
        rawProps = _ref2$props === void 0 ? {} : _ref2$props,
        _ref2$methods = _ref2.methods,
        methods = _ref2$methods === void 0 ? {} : _ref2$methods,
        _ref2$aliases = _ref2.aliases,
        aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases,
        _ref2$init = _ref2.init,
        initFn = _ref2$init === void 0 ? function () {} : _ref2$init,
        _ref2$update = _ref2.update,
        updateFn = _ref2$update === void 0 ? function () {} : _ref2$update;
    // Parse props into Prop instances
    var props = Object.keys(rawProps).map(function (propName) {
      return new Prop(propName, rawProps[propName]);
    });
    return function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Holds component state
      var state = Object.assign({}, stateInit instanceof Function ? stateInit(options) : stateInit, // Support plain objects for backwards compatibility
      {
        initialised: false
      }); // keeps track of which props triggered an update

      var changedProps = {}; // Component constructor

      function comp(nodeElement) {
        initStatic(nodeElement, options);
        digest();
        return comp;
      }

      var initStatic = function initStatic(nodeElement, options) {
        initFn.call(comp, nodeElement, state, options);
        state.initialised = true;
      };

      var digest = debounce_1(function () {
        if (!state.initialised) {
          return;
        }

        updateFn.call(comp, state, changedProps);
        changedProps = {};
      }, 1); // Getter/setter methods

      props.forEach(function (prop) {
        comp[prop.name] = getSetProp(prop);

        function getSetProp(_ref3) {
          var prop = _ref3.name,
              _ref3$triggerUpdate = _ref3.triggerUpdate,
              redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate,
              _ref3$onChange = _ref3.onChange,
              onChange = _ref3$onChange === void 0 ? function (newVal, state) {} : _ref3$onChange,
              _ref3$defaultVal = _ref3.defaultVal,
              defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
          return function (_) {
            var curVal = state[prop];

            if (!arguments.length) {
              return curVal;
            } // Getter mode


            var val = _ === undefined ? defaultVal : _; // pick default if value passed is undefined

            state[prop] = val;
            onChange.call(comp, val, state, curVal); // track changed props

            !changedProps.hasOwnProperty(prop) && (changedProps[prop] = curVal);

            if (redigest) {
              digest();
            }

            return comp;
          };
        }
      }); // Other methods

      Object.keys(methods).forEach(function (methodName) {
        comp[methodName] = function () {
          var _methods$methodName;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args));
        };
      }); // Link aliases

      Object.entries(aliases).forEach(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
            alias = _ref5[0],
            target = _ref5[1];

        return comp[alias] = comp[target];
      }); // Reset all component props to their default value

      comp.resetProps = function () {
        props.forEach(function (prop) {
          comp[prop.name](prop.defaultVal);
        });
        return comp;
      }; //


      comp.resetProps(); // Apply all prop defaults

      state._rerender = digest; // Expose digest method

      return comp;
    };
  }

  var three = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
  : {
    WebGLRenderer: three$1.WebGLRenderer,
    Scene: three$1.Scene,
    PerspectiveCamera: three$1.PerspectiveCamera,
    Raycaster: three$1.Raycaster,
    Vector2: three$1.Vector2,
    Vector3: three$1.Vector3,
    Color: three$1.Color,
    EventDispatcher: three$1.EventDispatcher,
    MOUSE: three$1.MOUSE,
    Quaternion: three$1.Quaternion,
    Spherical: three$1.Spherical
  };
  var ThreeOrbitControls = threeOrbitControls(three);
  var ThreeFlyControls = (threeFlyControls(three), three.FlyControls);
  var threeRenderObjects = index({
    props: {
      width: {
        "default": window.innerWidth,
        onChange: function onChange(width, state, prevWidth) {
          isNaN(width) && (state.width = prevWidth);
        }
      },
      height: {
        "default": window.innerHeight,
        onChange: function onChange(height, state, prevHeight) {
          isNaN(height) && (state.height = prevHeight);
        }
      },
      backgroundColor: {
        "default": '#000011',
        onChange: function onChange(bckgColor, state) {
          if (state.renderer) {
            var alpha = parseToRgb(bckgColor).alpha;
            if (alpha === undefined) alpha = 1;
            state.renderer.setClearColor(new three.Color(curriedOpacify(1, bckgColor)), alpha);
          }
        },
        triggerUpdate: false
      },
      showNavInfo: {
        "default": true
      },
      objects: {
        "default": [],
        onChange: function onChange(objs, state) {
          (state.prevObjs || []).forEach(function (obj) {
            return state.scene.remove(obj);
          }); // Clear the place

          state.prevObjs = objs;
          objs.forEach(function (obj) {
            return state.scene.add(obj);
          }); // Add to scene
        },
        triggerUpdate: false
      },
      postProcessingComposer: {
        triggerUpdate: false
      },
      enablePointerInteraction: {
        "default": true,
        onChange: function onChange(_, state) {
          // Reset hover state
          state.hoverObj = null;
          if (state.toolTipElem) state.toolTipElem.innerHTML = '';
        },
        triggerUpdate: false
      },
      lineHoverPrecision: {
        "default": 1,
        triggerUpdate: false
      },
      hoverOrderComparator: {
        "default": function _default() {
          return -1;
        },
        triggerUpdate: false
      },
      // keep existing order by default
      tooltipContent: {
        triggerUpdate: false
      },
      hoverDuringDrag: {
        "default": false,
        triggerUpdate: false
      },
      onHover: {
        "default": function _default() {},
        triggerUpdate: false
      },
      onClick: {
        "default": function _default() {},
        triggerUpdate: false
      },
      onRightClick: {
        triggerUpdate: false
      }
    },
    methods: {
      tick: function tick(state) {
        if (state.initialised) {
          state.controls.update && state.controls.update();
          state.postProcessingComposer ? state.postProcessingComposer.render() // if using postprocessing, render only the output of the
          : state.renderer.render(state.scene, state.camera);

          if (state.enablePointerInteraction) {
            // Update tooltip and trigger onHover events
            var topObject = null;

            if (state.hoverDuringDrag || !state.controlsDragging) {
              var raycaster = new three.Raycaster();
              raycaster.linePrecision = state.lineHoverPrecision;
              raycaster.setFromCamera(state.mousePos, state.camera);
              var intersects = raycaster.intersectObjects(state.objects, true).map(function (_ref) {
                var object = _ref.object;
                return object;
              }).sort(state.hoverOrderComparator);
              topObject = intersects.length ? intersects[0] : null;
            }

            if (topObject !== state.hoverObj) {
              state.onHover(topObject, state.hoverObj);
              state.toolTipElem.innerHTML = topObject ? accessorFn(state.tooltipContent)(topObject) || '' : '';
              state.hoverObj = topObject;
            }
          }

          TWEEN.update(); // update camera animation tweens
        }

        return this;
      },
      cameraPosition: function cameraPosition(state, position, lookAt, transitionDuration) {
        var camera = state.camera; // Setter

        if (position && state.initialised) {
          var finalPos = position;
          var finalLookAt = lookAt || {
            x: 0,
            y: 0,
            z: 0
          };

          if (!transitionDuration) {
            // no animation
            setCameraPos(finalPos);
            setLookAt(finalLookAt);
          } else {
            var camPos = Object.assign({}, camera.position);
            var camLookAt = getLookAt();
            new TWEEN.Tween(camPos).to(finalPos, transitionDuration).easing(TWEEN.Easing.Quadratic.Out).onUpdate(setCameraPos).start(); // Face direction in 1/3rd of time

            new TWEEN.Tween(camLookAt).to(finalLookAt, transitionDuration / 3).easing(TWEEN.Easing.Quadratic.Out).onUpdate(setLookAt).start();
          }

          return this;
        } // Getter


        return Object.assign({}, camera.position, {
          lookAt: getLookAt()
        }); //

        function setCameraPos(pos) {
          var x = pos.x,
              y = pos.y,
              z = pos.z;
          if (x !== undefined) camera.position.x = x;
          if (y !== undefined) camera.position.y = y;
          if (z !== undefined) camera.position.z = z;
        }

        function setLookAt(lookAt) {
          state.controls.target = new three.Vector3(lookAt.x, lookAt.y, lookAt.z);
        }

        function getLookAt() {
          return Object.assign(new three.Vector3(0, 0, -1000).applyQuaternion(camera.quaternion).add(camera.position));
        }
      },
      renderer: function renderer(state) {
        return state.renderer;
      },
      scene: function scene(state) {
        return state.scene;
      },
      camera: function camera(state) {
        return state.camera;
      },
      controls: function controls(state) {
        return state.controls;
      },
      tbControls: function tbControls(state) {
        return state.controls;
      } // to be deprecated

    },
    stateInit: function stateInit() {
      return {
        scene: new three.Scene(),
        camera: new three.PerspectiveCamera()
      };
    },
    init: function init(domNode, state, _ref2) {
      var _ref2$controlType = _ref2.controlType,
          controlType = _ref2$controlType === void 0 ? 'trackball' : _ref2$controlType,
          _ref2$rendererConfig = _ref2.rendererConfig,
          rendererConfig = _ref2$rendererConfig === void 0 ? {} : _ref2$rendererConfig;
      // Wipe DOM
      domNode.innerHTML = ''; // Add relative container

      domNode.appendChild(state.container = document.createElement('div'));
      state.container.style.position = 'relative'; // Add nav info section

      state.container.appendChild(state.navInfo = document.createElement('div'));
      state.navInfo.className = 'scene-nav-info';
      state.navInfo.textContent = {
        orbit: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
        trackball: 'Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan',
        fly: 'WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw'
      }[controlType] || '';
      state.navInfo.style.display = state.showNavInfo ? null : 'none'; // Setup tooltip

      state.toolTipElem = document.createElement('div');
      state.toolTipElem.classList.add('scene-tooltip');
      state.container.appendChild(state.toolTipElem); // Capture mouse coords on move

      state.mousePos = new three.Vector2();
      state.mousePos.x = -2; // Initialize off canvas

      state.mousePos.y = -2;
      state.container.addEventListener("mousemove", function (ev) {
        if (state.enablePointerInteraction) {
          // update the mouse pos
          var offset = getOffset(state.container),
              relPos = {
            x: ev.pageX - offset.left,
            y: ev.pageY - offset.top
          };
          state.mousePos.x = relPos.x / state.width * 2 - 1;
          state.mousePos.y = -(relPos.y / state.height) * 2 + 1; // Move tooltip

          state.toolTipElem.style.top = "".concat(relPos.y, "px");
          state.toolTipElem.style.left = "".concat(relPos.x, "px");
          state.toolTipElem.style.transform = "translate(-".concat(relPos.x / state.width * 100, "%, 21px)"); // adjust horizontal position to not exceed canvas boundaries
        }

        function getOffset(el) {
          var rect = el.getBoundingClientRect(),
              scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
              scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: rect.top + scrollTop,
            left: rect.left + scrollLeft
          };
        }
      }, false); // Handle click events on objs

      state.container.addEventListener('click', function (ev) {
        if (state.ignoreOneClick) {
          state.ignoreOneClick = false; // because of controls end event

          return;
        }

        state.onClick(state.hoverObj || null, ev); // trigger background clicks with null
      }, false); // Handle right-click events

      state.container.addEventListener('mouseup', function (ev) {
        if (ev.button === 2 && state.onRightClick) {
          if (state.ignoreOneClick) {
            state.ignoreOneClick = false; // because of controls end event

            return;
          }

          state.onRightClick(state.hoverObj || null, ev);
        }
      }, false); // Setup renderer, camera and controls

      state.renderer = new three.WebGLRenderer(Object.assign({
        antialias: true,
        alpha: true
      }, rendererConfig));
      state.renderer.setPixelRatio(window.devicePixelRatio);
      var bckgAlpha = parseToRgb(state.backgroundColor).alpha;
      if (bckgAlpha === undefined) bckgAlpha = 1;
      state.renderer.setClearColor(new three.Color(curriedOpacify(1, state.backgroundColor)), bckgAlpha);
      state.container.appendChild(state.renderer.domElement); // configure controls

      state.controls = new {
        trackball: threeTrackballcontrols,
        orbit: ThreeOrbitControls,
        fly: ThreeFlyControls
      }[controlType](state.camera, state.renderer.domElement);

      if (controlType === 'fly') {
        state.controls.movementSpeed = 2.5;
      }

      if (controlType === 'trackball' || controlType === 'orbit') {
        state.controls.minDistance = 0.1;
        state.controls.maxDistance = 50000;
        state.controls.addEventListener('start', function () {
          return state.controlsEngaged = true;
        });
        state.controls.addEventListener('change', function () {
          if (state.controlsEngaged) {
            state.controlsDragging = true;
            state.ignoreOneClick = true;
          }
        });
        state.controls.addEventListener('end', function () {
          state.controlsEngaged = false;
          state.controlsDragging = false;
        });
      }

      state.renderer.setSize(state.width, state.height);
      state.camera.aspect = state.width / state.height;
      state.camera.updateProjectionMatrix();
      state.camera.position.z = 1000;
      state.camera.far = 50000;
      window.scene = state.scene;
    },
    update: function update(state) {
      // resize canvas
      if (state.width && state.height) {
        state.container.style.width = state.width;
        state.container.style.height = state.height;
        state.renderer.setSize(state.width, state.height);
        state.camera.aspect = state.width / state.height;
        state.camera.updateProjectionMatrix();
      }

      state.navInfo.style.display = state.showNavInfo ? null : 'none';
    }
  });

  return threeRenderObjects;

})));
//# sourceMappingURL=three-render-objects.js.map
