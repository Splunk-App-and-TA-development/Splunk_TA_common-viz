'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var three = require('three');
var earcut = _interopDefault(require('earcut'));

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
: {
  BufferGeometry: three.BufferGeometry,
  Float32BufferAttribute: three.Float32BufferAttribute,
  Geometry: three.Geometry
};

function ConicPolygonGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides) {
  THREE.Geometry.call(this);
  this.type = 'ConicPolygonGeometry';
  this.parameters = {
    polygonGeoJson: polygonGeoJson,
    startHeight: startHeight,
    endHeight: endHeight,
    closedBottom: closedBottom,
    closedTop: closedTop,
    includeSides: includeSides
  };
  this.fromBufferGeometry(new ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides));
  this.mergeVertices();
}

ConicPolygonGeometry.prototype = Object.create(THREE.Geometry.prototype);
ConicPolygonGeometry.prototype.constructor = ConicPolygonGeometry;

function ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides) {
  THREE.BufferGeometry.call(this);
  this.type = 'ConicPolygonBufferGeometry';
  this.parameters = {
    polygonGeoJson: polygonGeoJson,
    startHeight: startHeight,
    endHeight: endHeight,
    closedBottom: closedBottom,
    closedTop: closedTop,
    includeSides: includeSides
  }; // defaults

  startHeight = startHeight || 0;
  endHeight = endHeight || 1;
  closedBottom = closedBottom !== undefined ? closedBottom : true;
  closedTop = closedTop !== undefined ? closedTop : true;
  includeSides = includeSides !== undefined ? includeSides : true; // calc vertices & indices

  var _generateVertices = generateVertices(startHeight),
      bottomVerts = _generateVertices.vertices,
      holes = _generateVertices.holes;

  var _generateVertices2 = generateVertices(endHeight),
      topVerts = _generateVertices2.vertices;

  var numPoints = Math.round(topVerts.length / 3);
  var vertices = [].concat(_toConsumableArray(topVerts), _toConsumableArray(bottomVerts));
  var indices = [];
  var groupCnt = 0; // add groups to apply different materials to torso / caps

  if (includeSides) {
    var prevIndCnt = indices.length;
    indices = indices.concat(generateTorso());
    this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);
  }

  if (closedBottom) {
    var _prevIndCnt = indices.length;
    indices = indices.concat(generateCap(false));
    this.addGroup(_prevIndCnt, indices.length - _prevIndCnt, groupCnt++);
  }

  if (closedTop) {
    var _prevIndCnt2 = indices.length;
    indices = indices.concat(generateCap(true));
    this.addGroup(_prevIndCnt2, indices.length - _prevIndCnt2, groupCnt++);
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); //

  function generateVertices(altitude) {
    var coords3d = polygonGeoJson.map(function (coords) {
      return coords.map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            lng = _ref2[0],
            lat = _ref2[1];

        return polar2Cartesian(lat, lng, altitude);
      });
    }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).

    return earcut.flatten(coords3d);
  }

  function generateTorso() {
    var holesIdx = new Set(holes);
    var lastHoleIdx = 0;
    var indices = [];

    for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {
      var v1Idx = v0Idx + 1; // next point

      if (v1Idx === numPoints) {
        v1Idx = lastHoleIdx; // close final loop
      } else if (holesIdx.has(v1Idx)) {
        var holeIdx = v1Idx;
        v1Idx = lastHoleIdx; // close hole loop

        lastHoleIdx = holeIdx;
      } // Each pair of coords generates two triangles (faces)


      indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);
      indices.push(v1Idx + numPoints, v1Idx, v0Idx);
    }

    return indices;
  }

  function generateCap() {
    var top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    // !! using the 3d coords generates shapes with the wrong winding, connecting the outsides of the contour
    // so we derive the indexes from the lat,lng coordinates directly
    // let capIndices = earcut(top ? topVerts : bottomVerts, holes, 3);
    var capIndices = earcut(earcut.flatten(polygonGeoJson).vertices, holes, 2);
    !top && (capIndices = capIndices.map(function (v) {
      return v + numPoints;
    })); // translate bottom indices

    return capIndices;
  }
}

ConicPolygonBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
ConicPolygonBufferGeometry.prototype.constructor = ConicPolygonBufferGeometry; //

function polar2Cartesian(lat, lng) {
  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var phi = (90 - lat) * Math.PI / 180;
  var theta = (90 - lng) * Math.PI / 180;
  return [r * Math.sin(phi) * Math.cos(theta), // x
  r * Math.cos(phi), // y
  r * Math.sin(phi) * Math.sin(theta) // z
  ];
}

exports.ConicPolygonBufferGeometry = ConicPolygonBufferGeometry;
exports.ConicPolygonGeometry = ConicPolygonGeometry;
