'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var three = require('three');

var fragmentShader = "\nuniform vec3 color;\nuniform float coefficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity\t= pow(\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\n    power\n  );\n  gl_FragColor = vec4(color, intensity);\n}";
var vertexShader = "\nvarying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvoid main() {\n  vVertexNormal\t= normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";
// Based off: http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html
function createGlowMaterial(coefficient, color, power) {
    return new three.ShaderMaterial({
        depthWrite: false,
        fragmentShader: fragmentShader,
        transparent: true,
        uniforms: {
            coefficient: {
                type: 'f',
                value: coefficient,
            },
            color: {
                type: 'c',
                value: new three.Color(color),
            },
            power: {
                type: 'f',
                value: power,
            },
        },
        vertexShader: vertexShader,
    });
}
function createGlowGeometry(geometry, size) {
    // gather vertexNormals from geometry.faces
    var glowGeometry = geometry.clone();
    var vertexNormals = new Array(glowGeometry.vertices.length);
    glowGeometry.faces.forEach(function (face) {
        if (face instanceof three.Face3) {
            vertexNormals[face.a] = face.vertexNormals[0];
            vertexNormals[face.b] = face.vertexNormals[1];
            vertexNormals[face.c] = face.vertexNormals[2];
        }
        else {
            console.error('Face needs to be an instance of THREE.Face3.');
        }
    });
    // modify the vertices according to vertexNormal
    glowGeometry.vertices.forEach(function (vertex, i) {
        var _a = vertexNormals[i], x = _a.x, y = _a.y, z = _a.z;
        vertex.x += x * size;
        vertex.y += y * size;
        vertex.z += z * size;
    });
    return glowGeometry;
}
var defaultOptions = {
    backside: true,
    coefficient: 0.5,
    color: 'gold',
    size: 2,
    power: 1,
};
function createGlowMesh(geometry, options) {
    if (options === void 0) { options = defaultOptions; }
    var backside = options.backside, coefficient = options.coefficient, color = options.color, size = options.size, power = options.power;
    var glowGeometry = createGlowGeometry(geometry, size);
    var glowMaterial = createGlowMaterial(coefficient, color, power);
    if (backside) {
        glowMaterial.side = three.BackSide;
    }
    return new three.Mesh(glowGeometry, glowMaterial);
}

exports.createGlowGeometry = createGlowGeometry;
exports.createGlowMaterial = createGlowMaterial;
exports.createGlowMesh = createGlowMesh;
exports.defaultOptions = defaultOptions;
